// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios14.4-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MZSwifts
import CoreGraphics
import Foundation
@_exported import MZSwifts
import MobileCoreServices
import Swift
import UIKit
public class MZTimer {
  public var isCancelled: Swift.Bool {
    get
  }
  public var state: MZSwifts.MZTimer.State {
    get
  }
  public init(repeating: Dispatch.DispatchTimeInterval, queue: Dispatch.DispatchQueue? = nil, event: (() -> ())?)
  public func resume()
  public func suspend()
  public func activate()
  public func cancel()
  @objc deinit
}
extension MZTimer {
  public enum State {
    case suspended
    case resumed
    public static func == (a: MZSwifts.MZTimer.State, b: MZSwifts.MZTimer.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public typealias MZFloat = Swift.Double
extension Double {
  public var float: Swift.Float {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
}
extension Float : MZSwifts.MZFloatToStringProtocol {
  public var int: Swift.Int {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var mzFloat: MZSwifts.MZFloat {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
  public init?(localed string: Swift.String, as locale: Foundation.Locale)
}
extension Double : MZSwifts.MZFloatToStringProtocol {
  public init?(localed string: Swift.String, as locale: Foundation.Locale)
}
extension Int {
  public var mzFloat: MZSwifts.MZFloat {
    get
  }
  public var cgFloat: CoreGraphics.CGFloat {
    get
  }
  public var float: Swift.Float {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var int32: Swift.Int32 {
    get
  }
  public var uint: Swift.UInt {
    get
  }
  public var uint16: Swift.UInt16 {
    get
  }
}
extension UInt {
  public var int: Swift.Int {
    get
  }
  public var int32: Swift.Int32 {
    get
  }
}
extension Bool {
  public func string(true: Swift.String = "true", false: Swift.String = "false") -> Swift.String
}
public protocol MZFloatToStringProtocol {
  init?(localed string: Swift.String, as locale: Foundation.Locale)
  func string(digits: Swift.Int?, locale: Foundation.Locale?) -> Swift.String
}
extension MZFloatToStringProtocol where Self : Swift.CVarArg {
  public func string(digits: Swift.Int? = nil, locale: Foundation.Locale? = nil) -> Swift.String
}
extension String {
  public func int(removeNonNumbersCharacters: Swift.Bool = true, locale: Foundation.Locale = Locale.current) -> Swift.Int?
  public func float(removeNonNumbersCharacters: Swift.Bool = true, locale: Foundation.Locale = Locale.current) -> Swift.Float?
  public func double(removeNonNumbersCharacters: Swift.Bool = true, locale: Foundation.Locale = Locale.current) -> Swift.Double?
  public func cgFloat(removeNonNumbersCharacters: Swift.Bool = true, locale: Foundation.Locale = Locale.current) -> CoreGraphics.CGFloat?
  public func mzFloat(removeNonNumbersCharacters: Swift.Bool = true, locale: Foundation.Locale = Locale.current) -> MZSwifts.MZFloat?
}
public struct MZVector {
  public static func unitVector(ofDegrees degrees: MZSwifts.MZFloat) -> CoreGraphics.CGVector
  public static func unitVector(ofRadians radians: MZSwifts.MZFloat) -> CoreGraphics.CGVector
  public static func unitVector(from: CoreGraphics.CGPoint, to: CoreGraphics.CGPoint) -> CoreGraphics.CGVector
  public static func vector(fromVector vector: CoreGraphics.CGVector, mapToRadians radians: MZSwifts.MZFloat) -> CoreGraphics.CGVector
  public static func vector(fromVector vector: CoreGraphics.CGVector, mapToDegrees degrees: MZSwifts.MZFloat) -> CoreGraphics.CGVector
  public static func dot(vector1: CoreGraphics.CGVector, vector2: CoreGraphics.CGVector) -> MZSwifts.MZFloat
  public static func length(ofVector vector: CoreGraphics.CGVector) -> MZSwifts.MZFloat
}
public struct MZEnvironment {
  public static func isSimulator() -> Swift.Bool
  public static func isDevice() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class MZUnit {
  @objc deinit
}
extension MZUnit {
  @_hasMissingDesignatedInitializers public class Length {
    public static func meter(ofFeet feet: MZSwifts.MZFloat) -> MZSwifts.MZFloat
    public static func feet(ofMeter meter: MZSwifts.MZFloat) -> MZSwifts.MZFloat
    @objc deinit
  }
}
extension MZUnit {
  @_hasMissingDesignatedInitializers public class Temperature {
    public static func fahrenheit(ofCelsius celsius: MZSwifts.MZFloat) -> MZSwifts.MZFloat
    public static func celsius(ofFahrenheit fahrenheit: MZSwifts.MZFloat) -> MZSwifts.MZFloat
    @objc deinit
  }
}
extension MZUnit {
  public enum MeasurementSystem : Swift.CaseIterable {
    case metric
    case imperial
    public static func == (a: MZSwifts.MZUnit.MeasurementSystem, b: MZSwifts.MZUnit.MeasurementSystem) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [MZSwifts.MZUnit.MeasurementSystem]
    public static var allCases: [MZSwifts.MZUnit.MeasurementSystem] {
      get
    }
  }
}
extension CGFloat : MZSwifts.MZFloatToStringProtocol {
  public var mzFloat: MZSwifts.MZFloat {
    get
  }
  public var double: Swift.Double {
    get
  }
  public var float: Swift.Float {
    get
  }
  public var int: Swift.Int {
    get
  }
  public init?(localed string: Swift.String, as locale: Foundation.Locale)
}
extension CGPoint {
  public static var one: CoreGraphics.CGPoint {
    get
  }
  public init(x: Swift.Float, y: Swift.Float)
  public init(size: CoreGraphics.CGSize)
  public var size: CoreGraphics.CGSize {
    get
  }
  public var vector: CoreGraphics.CGVector {
    get
  }
}
public func + (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
public func - (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
public func * (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
public func * (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
public func / (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
public func / (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
public func += (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint)
public func -= (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint)
public func *= (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGFloat)
public func *= (lhs: inout CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint)
extension CGSize {
  public static var zero: CoreGraphics.CGSize {
    get
  }
  public static var one: CoreGraphics.CGSize {
    get
  }
  public var point: CoreGraphics.CGPoint {
    get
  }
  public var maxEdge: CoreGraphics.CGFloat {
    get
  }
  public var minEdge: CoreGraphics.CGFloat {
    get
  }
  public init(widthHeight: CoreGraphics.CGFloat)
}
public func + (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
public func - (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
public func * (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
public func * (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGSize
public func / (lhs: CoreGraphics.CGSize, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
extension CGRect {
  public static var one: CoreGraphics.CGRect {
    get
  }
  public init(center: CoreGraphics.CGPoint, size: CoreGraphics.CGSize)
  public init(centerX: CoreGraphics.CGFloat, centerY: CoreGraphics.CGFloat, width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  public init(size: CoreGraphics.CGSize)
  public init(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  public var center: CoreGraphics.CGPoint {
    get
    set
  }
  public func width(withLerp lerp: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  public func height(withLerp lerp: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  public func xPosition(withLerp lerp: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  public func yPosition(withLerp lerp: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
  public func position(withXLerp xLerp: CoreGraphics.CGFloat, andYLerp yLerp: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  public var topLeft: CoreGraphics.CGPoint {
    get
  }
  public var topRight: CoreGraphics.CGPoint {
    get
  }
  public var bottomLeft: CoreGraphics.CGPoint {
    get
  }
  public var bottomRight: CoreGraphics.CGPoint {
    get
  }
}
public func * (lhs: CoreGraphics.CGRect, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
extension CGVector {
  public func mapToRadians(radians: CoreGraphics.CGFloat) -> CoreGraphics.CGVector
  public var point: CoreGraphics.CGPoint {
    get
  }
}
public func + (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGVector) -> CoreGraphics.CGVector
public func - (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGVector) -> CoreGraphics.CGVector
public func * (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGVector
public func * (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGVector) -> CoreGraphics.CGVector
public func / (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGFloat) -> CoreGraphics.CGVector
public func / (lhs: CoreGraphics.CGVector, rhs: CoreGraphics.CGVector) -> CoreGraphics.CGVector
public func += (lhs: inout CoreGraphics.CGVector, rhs: CoreGraphics.CGVector)
public func -= (lhs: inout CoreGraphics.CGVector, rhs: CoreGraphics.CGVector)
public func *= (lhs: inout CoreGraphics.CGVector, rhs: CoreGraphics.CGFloat)
public func /= (lhs: inout CoreGraphics.CGVector, rhs: CoreGraphics.CGFloat)
public func * (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGPoint
extension String {
  public func toInt(ignores: [Swift.String] = [], trimInvalid: Swift.Bool = false) -> Swift.Int?
  public func toDouble(ignores: [Swift.String] = [], trimInvalid: Swift.Bool = false) -> Swift.Double?
  public func toSeconds() -> Swift.Double?
}
extension DispatchTimeInterval {
  public static func with(seconds: Swift.Double) -> Dispatch.DispatchTimeInterval
  public static func now(after seconds: Swift.Double) -> Dispatch.DispatchTime
}
extension DispatchTime {
  public static func now(after seconds: Swift.Double) -> Dispatch.DispatchTime
}
public struct MZMath {
  public static func lerp(numerator: MZSwifts.MZFloat, denominator: MZSwifts.MZFloat, canOverOne: Swift.Bool = false) -> MZSwifts.MZFloat
  public static func lerp(numerator: CoreGraphics.CGFloat, denominator: CoreGraphics.CGFloat, canOverOne: Swift.Bool = false) -> CoreGraphics.CGFloat
  public static func valueInBound<T>(origin: T, lower: T, upper: T) -> T where T : Swift.Comparable
}
extension MZMath {
  public static func greatestCommonDivisorOf(_ a: Swift.Int, _ b: Swift.Int) -> Swift.Int
  public static func gcd(_ a: Swift.Int, _ b: Swift.Int) -> Swift.Int
}
extension MZMath {
  public static func distancePow2(from: CoreGraphics.CGPoint, to: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
  public static func distance(from: CoreGraphics.CGPoint, to: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
}
@_hasMissingDesignatedInitializers public class MZType {
  public class func className(ofObject object: Swift.AnyObject) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MZJson {
  public class func jsonData(ofAny any: Any) -> Foundation.Data?
  public class func jsonData(ofDictionary dictionary: [Swift.String : Swift.AnyObject]) -> Foundation.Data?
  public class func jsonString(from data: Foundation.Data) -> Swift.String?
  public class func jsonString(from dictionary: [Swift.String : Swift.AnyObject]) -> Swift.String?
  public class func array(from jsonString: Swift.String) -> [Swift.AnyObject]?
  public class func dictionary(from jsonString: Swift.String) -> [Swift.String : Swift.AnyObject]?
  @objc deinit
}
public struct MZWeight {
  public var gram: MZSwifts.MZWeight {
    get
  }
  public var ounce: MZSwifts.MZWeight {
    get
  }
  public var value: Swift.Double {
    get
  }
  public var unit: MZSwifts.MZWeight.Unit {
    get
  }
  public var formatter: MZSwifts.MZWeight.Formatter {
    get
  }
  public init(_ value: Swift.Double)
  public func setFormatter(_ formatter: MZSwifts.MZWeight.Formatter) -> MZSwifts.MZWeight
}
extension MZWeight {
  public enum Unit {
    case gram
    case ounce
    public var text: Swift.String {
      get
    }
    public var shortText: Swift.String {
      get
    }
    public static func == (a: MZSwifts.MZWeight.Unit, b: MZSwifts.MZWeight.Unit) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension MZWeight {
  public static func gram(fromOunce ounce: Swift.Double) -> Swift.Double
  public static func ounce(fromGram gram: Swift.Double) -> Swift.Double
}
extension MZWeight {
  public static func + (lhs: MZSwifts.MZWeight, rhs: MZSwifts.MZWeight) -> MZSwifts.MZWeight
  public static func - (lhs: MZSwifts.MZWeight, rhs: MZSwifts.MZWeight) -> MZSwifts.MZWeight
}
extension MZWeight {
  public class Formatter {
    public static let shared: MZSwifts.MZWeight.Formatter
    public var digitsOfGram: Swift.Int
    public var digitsOfOunce: Swift.Int
    public var hideUnitText: Swift.Bool
    public var useShortUnitText: Swift.Bool
    public var addSpaceBeforeUnit: Swift.Bool
    public init(digitsOfGram: Swift.Int = 1, digitsOfOunce: Swift.Int = 3, hideUnitText: Swift.Bool = false, useShortUnitText: Swift.Bool = false, addSpaceBeforeUnit: Swift.Bool = true)
    public func digits(for unit: MZSwifts.MZWeight.Unit) -> Swift.Int
    @objc deinit
  }
}
extension MZWeight : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public func string(digits: Swift.Int? = nil, locale: Foundation.Locale? = nil) -> Swift.String
}
extension Double {
  public var weight: MZSwifts.MZWeight {
    get
  }
}
@_hasMissingDesignatedInitializers public class MZImage {
  public enum Format {
    case png
    case jpg(compressionQuality: CoreGraphics.CGFloat)
  }
  public class func cropping(cgImage: CoreGraphics.CGImage, toRect cropRect: CoreGraphics.CGRect) -> CoreGraphics.CGImage?
  public class func cropping(uiImage: UIKit.UIImage, toRect cropRect: CoreGraphics.CGRect) -> UIKit.UIImage?
  public class func rotate(uiImage image: UIKit.UIImage?, orientation: UIKit.UIImage.Orientation) -> UIKit.UIImage?
  @objc deinit
}
extension UIImage {
  public func data(as format: MZSwifts.MZImage.Format = .png) -> Foundation.Data?
  public func normalized() -> UIKit.UIImage
  public func resized(to targetSize: CoreGraphics.CGSize) -> UIKit.UIImage
  public func resized(maxEdge: CoreGraphics.CGFloat, forceResizeIfLess: Swift.Bool = false) -> UIKit.UIImage
}
@_hasMissingDesignatedInitializers public class MZDataExtension {
  @objc deinit
}
extension Data {
  public func copyBytes<ConvertedType>(to array: inout [ConvertedType])
  public func copyBytes<ConvertedType>(to value: inout ConvertedType)
}
@objc @_inheritsConvenienceInitializers public class MZMediaLibraryPicker : ObjectiveC.NSObject {
  @available(iOS 13.0, *)
  public func show(in parent: UIKit.UIViewController, sourceType: UIKit.UIImagePickerController.SourceType, modalPresentationStyle: UIKit.UIModalPresentationStyle = .automatic, completed: (() -> ())? = nil, done: ((UIKit.UIImage?) -> ())?)
  public func show(in parent: UIKit.UIViewController, sourceType: UIKit.UIImagePickerController.SourceType, completed: (() -> ())? = nil, done: ((UIKit.UIImage?) -> ())?)
  @objc deinit
  @objc override dynamic public init()
}
extension MZMediaLibraryPicker : UIKit.UIImagePickerControllerDelegate, UIKit.UINavigationControllerDelegate {
  @objc dynamic public func imagePickerController(_ picker: UIKit.UIImagePickerController, didFinishPickingMediaWithInfo info: [UIKit.UIImagePickerController.InfoKey : Any])
  @objc dynamic public func imagePickerControllerDidCancel(_ picker: UIKit.UIImagePickerController)
}
public protocol MZNotificationComponentEventProtocol : Swift.CaseIterable {
  var notificationName: Foundation.Notification.Name { get }
}
public protocol MZNotificationComponentProtocol {
  associatedtype NotifyEvent
  var baseCenter: Foundation.NotificationCenter { get }
  func observe(_ event: Self.NotifyEvent, observer: Any, action: ObjectiveC.Selector)
  func remove(observer: Any, event: Self.NotifyEvent)
  func remove(observer: Any)
  func post(_ event: Self.NotifyEvent, userInfo: [Swift.AnyHashable : Any]?)
}
extension MZNotificationComponentProtocol where Self.NotifyEvent : MZSwifts.MZNotificationComponentEventProtocol {
  public var baseCenter: Foundation.NotificationCenter {
    get
  }
  public func observe(_ event: Self.NotifyEvent, observer: Any, action: ObjectiveC.Selector)
  public func observe(_ event: Self.NotifyEvent, queue: Foundation.OperationQueue?, using block: @escaping (Foundation.Notification) -> Swift.Void) -> ObjectiveC.NSObjectProtocol
  public func remove(observer: Any, event: Self.NotifyEvent)
  public func remove(observer: Any)
  public func post(_ event: Self.NotifyEvent, userInfo: [Swift.AnyHashable : Any]? = nil)
}
@_hasMissingDesignatedInitializers public class MZAngle {
  public enum CircularMotion : Swift.Int, Swift.CaseIterable, Swift.CustomStringConvertible {
    case clockwise
    case counterClockwise
    public var description: Swift.String {
      get
    }
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
    public typealias AllCases = [MZSwifts.MZAngle.CircularMotion]
    public static var allCases: [MZSwifts.MZAngle.CircularMotion] {
      get
    }
  }
  public class func degrees(ofRadians radians: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  public class func radians(ofDegrees degree: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  public class func formatDegree(_ origin: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  public class func degree(fromVector from: CoreGraphics.CGVector, toVector to: CoreGraphics.CGVector) -> MZSwifts.MZFloat
  public class func degree(fromXAxisToVector vector: CoreGraphics.CGVector) -> MZSwifts.MZFloat
  public class func radians(fromXAxisToVector vector: CoreGraphics.CGVector) -> MZSwifts.MZFloat
  public class func degress(from: CoreGraphics.CGPoint, to: CoreGraphics.CGPoint) -> MZSwifts.MZFloat
  public class func radians(from: CoreGraphics.CGPoint, to: CoreGraphics.CGPoint) -> MZSwifts.MZFloat
  public class func isOver(from: MZSwifts.MZFloat, to: MZSwifts.MZFloat, add: MZSwifts.MZFloat, circularMotion: MZSwifts.MZAngle.CircularMotion = CircularMotion.counterClockwise) -> Swift.Bool
  public class func shortestDegreeDistance(from: MZSwifts.MZFloat, to: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  @objc deinit
}
extension Date {
  public func string(withFormat format: Swift.String? = "yyyyMMdd-HHmmss", local: Foundation.Locale? = nil, timeZone: Foundation.TimeZone? = nil) -> Swift.String
  public func string(dateStyle: Foundation.DateFormatter.Style, local: Foundation.Locale? = nil, timeZone: Foundation.TimeZone? = nil) -> Swift.String
}
extension Data {
  public var kilobyte: Swift.Float {
    get
  }
  public var megabyte: Swift.Float {
    get
  }
}
public class MZShapeEllipse {
  public var center: CoreGraphics.CGPoint
  public var a: MZSwifts.MZFloat
  public var b: MZSwifts.MZFloat
  public init(center: CoreGraphics.CGPoint, a: MZSwifts.MZFloat, b: MZSwifts.MZFloat)
  public func xWithRadians(radians: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  public func yWithRadians(radians: MZSwifts.MZFloat) -> MZSwifts.MZFloat
  public func positionWithRadians(radians: MZSwifts.MZFloat) -> CoreGraphics.CGPoint
  public func positionWithDegrees(degrees: MZSwifts.MZFloat) -> CoreGraphics.CGPoint
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MZDebug {
  public static var isEnable: Swift.Bool
  public class func log(_ item: Any? = nil, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func logFunctionName(prefix: Swift.String? = nil, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func timeLog(_ message: Swift.String, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func assert(predicate: @autoclosure () -> Swift.Bool, message: Swift.String, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func assert(noNil target: Any?)
  public class func assertAlwayFalse(_ message: Swift.String, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func overrideMe(filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line) -> Swift.Never
  public class func youCannotPass(filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line) -> Swift.Never
  public class func implementMe(filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line)
  public class func formatLogString(filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line) -> Swift.String
  public class func fileNameInPath(path: Swift.String = #file) -> Swift.String
  public class func fatalError(_ message: Swift.String, filePath: Swift.String = #file, functionName: Swift.String = #function, line: Swift.Int = #line) -> Swift.Never
  public class func logDocumentPath()
  @objc deinit
}
extension MZDebug {
  public class func fatalUnkonowSegue(to any: Any)
}
@_hasMissingDesignatedInitializers public class MZPath {
  public static var appDocument: Swift.String {
    get
  }
  @objc deinit
}
extension MZSwifts.MZTimer.State : Swift.Equatable {}
extension MZSwifts.MZTimer.State : Swift.Hashable {}
extension MZSwifts.MZUnit.MeasurementSystem : Swift.Equatable {}
extension MZSwifts.MZUnit.MeasurementSystem : Swift.Hashable {}
extension MZSwifts.MZWeight.Unit : Swift.Equatable {}
extension MZSwifts.MZWeight.Unit : Swift.Hashable {}
extension MZSwifts.MZAngle.CircularMotion : Swift.Equatable {}
extension MZSwifts.MZAngle.CircularMotion : Swift.Hashable {}
extension MZSwifts.MZAngle.CircularMotion : Swift.RawRepresentable {}
